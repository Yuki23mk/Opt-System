◆開発メモ◆
言語
フロントエンド: React + Next.js + TypeScript
バックエンド: Node.js + Next.js API Routes + TypeScript
データベース: PostgreSQL + Prisma

OptiOilは JavaScript / TypeScript を採用し、Node.js + Next.js を基盤とする 方針で決定。

発注管理×機械データ連携

・Pythonコード実行するときは、py コマンドを使う！（pythonコマンドだとWindows環境ではエラーになって実行できなかった）

★API実装
import bcrypt from 'bcrypt' のような部分は、「外部API」ではなく、「外部ライブラリ」を使っています。これについて詳しく説明します。
例えば、bcrypt はパスワードのハッシュ化や検証のためのライブラリです。
1. セキュリティ対応が早い
bcrypt や jsonwebtoken のようなライブラリは、セキュリティの専門家がメンテナンス しています。
新しい脆弱性が発見されたときに、素早くアップデート が提供されます。
自作でハッシュ化やトークン管理を行うと、セキュリティリスクが高まります。

2. コード量が減ってシンプルになる
例えば、bcrypt を使わない場合、自分で ハッシュアルゴリズムやソルトの管理 が必要になります。
jsonwebtoken を使わないと、トークンの暗号化と検証 をゼロから実装しないといけません。

自作だとメンテナンスコストが増えるだけでなく、バグやセキュリティリスクも高くなります。
外部ライブラリを使うことで、安全で効率的なコードを保ちやすくなる ので、メンテナンスは圧倒的に楽になります。


はい、実装した認証APIは商用利用が可能です！
以下の理由で問題ありません。

📌 1. 使用ライブラリのライセンス
✅ bcrypt のライセンス: MITライセンス
商用利用: OK
コードの改変・再配布: OK
著作権表示の保持: 必須
✅ jsonwebtoken のライセンス: MITライセンス
商用利用: OK
コードの改変・再配布: OK
著作権表示の保持: 必須
✅ Prisma のライセンス: Apache 2.0ライセンス
商用利用: OK
特許権の保護: OK
著作権表示の保持: 必須
✅ Next.js のライセンス: MITライセンス
商用利用: OK
カスタマイズ: OK


【ログイン画面のURLは環境変数にした】
4/19
「JWTにはIDだけ」、個人情報はすべてDBから取得の方針にした。
※JWTは改ざんはできないけど、誰でも見れるので項目は絞る必要がある。
→JWTに全部入れていたので方針を変更した。

4/20
JWT を 発行 (sign) / 検証 (verify) する処理が、点在していたのを一か所にまとめた。
これで、署名のアルゴリズムを変えたり失効時間を変えるなどのポリシー変更は 1 ファイル修正で完了するし、型定義も 1 か所なので payload のミスが TS で検知できるらしい。

4/23
CredentialsProvider（email+password）はJWT ストラテジーでのみ動作可能ということで、JWTやめてセッション方式にしようとしてたけどやはりJWTを利用することにした。ただし、最小限で。

フロントエンドのログイン画面を決め打ちしてたけど環境変数ファイル（.env.local)に別出しにしてメンテ性を高める。
✅ 注意点（本番ビルド後）
★.env.local は ビルド時に読み込まれるので、環境を変えたら npm run build を再実行！
★Vercel や Netlify では管理画面から NEXT_PUBLIC_API_URL を設定できます
対象	環境変数化すべき？	理由
fetch先URL（APIエンドポイント）→環境変数化すべき：本番・開発で変わるから（インターネット経由するから）
componentsやutilsのimport→環境変数化しない！ローカル固定のファイルだから

4/27
★開発方針★「環境変数ベースでAPIパスを組み立てる」＋「fetchのパスを相対指定しない」
JWTに個人情報を含めない構成に切り替え、セッションから id を取得して DB からユーザー情報を取得する方式に変更した。
prisma.user.findUnique() を使い、該当のカラムを含む情報が取得できる
5/1 サブアカウントの更新ができるようになった
アカウント画面の情報更新は、一律で[userID]を活用している。（中で条件分岐し、制御している）
login.ts内にJWTの内容がある。ここには個人情報を入れず最低限にすべき。

5/2アカウント画面とか、localStorage.getItem("token") でとるのをやめてprops.token(Authenti..Bearer..のやつ）で取ることにした
つまり、Authorization: Bearer ${token} 形式で統一（セッション認証ではなくトークン方式の維持）
5/22
詳細ページでレイアウトを古いものから引っ張ってきて崩れを直した
開発環境では、設備一覧＞ドキュメントで、アップロードしたあとBEのpublic/uploadsのファイルをFEのpublic/uploadsへ移す必要あり（閲覧とDLを動作させるため）
5/27
APIのプロジェクトルート内について： adminは管理者用API,それ以外はユーザAPI.txt
5/29
タグを追加、編集、削除できるのはメインアカウントのみ。サブアカウントは閲覧のみ。
FEは、appとcomponentsの中にtsxファイルがある
5/30
注文ステータスは以下。DBに登録されたpendingとかが、コード上で日本語ステータスへ変換される
    'pending': { text: '注文受付', color: 'bg-blue-100 text-blue-800' },
    'confirmed': { text: '注文確定', color: 'bg-green-100 text-green-800' },
    'preparing': { text: '準備中', color: 'bg-yellow-100 text-yellow-800' },
    'shipped': { text: '配送中', color: 'bg-purple-100 text-purple-800' },
    'delivered': { text: '配送完了', color: 'bg-gray-100 text-gray-800' },
    'cancelled': { text: 'キャンセル'
5/31
管理者用画面
super_admin: 1〜2名のシステム管理者

新しい管理者の追加
管理者のパスワードリセット
全機能の利用


admin: 日常業務を行う管理者（複数名）

受注処理、商品管理などの業務機能
管理者アカウント関連は操作不可

6/14　共有コンポーネントとしてトースト、アラート、確認モーダルをユーザFEにおいて、それを利用するようにして言っている（統一化）。
製品一覧、注文履歴は対応済（多分）
